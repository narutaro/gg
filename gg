#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
gg_usage() {
  printf "gg - Yet another set of Greengrass development commands â€“ but one that feels just right.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg COMMAND\n"
  printf "  gg [COMMAND] --help | -h\n"
  printf "  gg --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   List project templates\n" "$(green "template")         "
  printf "  %s   Manage components\n" "$(green "component")        "
  printf "  %s   Manage remote deployments\n" "$(green "remote-deployment")"
  printf "  %s   Manage local deployments\n" "$(green "local-deployment") "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(green "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(green "MESSAGE_LEVEL")"
    printf "    Set the command message level\n"
    printf "    %s\n" "Allowed: DEBUG, INFO, WARN, ERROR"
    printf "    %s\n" "Default: INFO"
    echo

  fi
}

# :command.usage
gg_template_usage() {
  printf "gg template - List project templates\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg template\n"
  printf "  gg template --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
gg_component_usage() {
  printf "gg component - Manage components\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component COMMAND\n"
  printf "  gg component [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Initialize a new component\n" "$(green "init")    "
  printf "  %s   Build the component and prepare its artifacts\n" "$(green "build")   "
  printf "  %s   Upload the component artifacts to S3\n" "$(green "push")    "
  printf "  %s   Register the component in AWS\n" "$(green "create")  "
  printf "  %s   Automate build, push, and create in one command\n" "$(green "pipeline")"
  printf "  %s   Display available component versions\n" "$(green "versions")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
gg_component_init_usage() {
  printf "gg component init - Initialize a new component\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component init COMPONENT_NAME [OPTIONS]\n"
  printf "  gg component init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--template, -t COMPONENT_TEMPLATE")"
    printf "    See $command_name template for options.\n"
    printf "    %s\n" "Default: python/hello-world"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_NAME")"
    printf "    Component name\n"
    echo

  fi
}

# :command.usage
gg_component_build_usage() {
  printf "gg component build - Build the component and prepare its artifacts\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component build COMPONENT_VERSION\n"
  printf "  gg component build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_VERSION")"
    printf "    Component version\n"
    echo

  fi
}

# :command.usage
gg_component_push_usage() {
  printf "gg component push - Upload the component artifacts to S3\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component push COMPONENT_VERSION\n"
  printf "  gg component push --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_VERSION")"
    printf "    Component version\n"
    echo

  fi
}

# :command.usage
gg_component_create_usage() {
  printf "gg component create - Register the component in AWS\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component create COMPONENT_VERSION\n"
  printf "  gg component create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_VERSION")"
    printf "    Component version\n"
    echo

  fi
}

# :command.usage
gg_component_pipeline_usage() {
  printf "gg component pipeline - Automate build, push, and create in one command\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component pipeline COMPONENT_VERSION\n"
  printf "  gg component pipeline --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_VERSION")"
    printf "    Component version\n"
    echo

  fi
}

# :command.usage
gg_component_versions_usage() {
  printf "gg component versions - Display available component versions\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component versions COMMAND\n"
  printf "  gg component versions [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Show public component versions\n" "$(green "public")"
  printf "  %s   Show custom component versions\n" "$(green "custom")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
gg_component_versions_public_usage() {
  printf "gg component versions public - Show public component versions\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component versions public COMPONENT_NAME\n"
  printf "  gg component versions public --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_NAME")"
    printf "    Public component name (aws.greengrass. prefix can be omitted)\n"
    echo

  fi
}

# :command.usage
gg_component_versions_custom_usage() {
  printf "gg component versions custom - Show custom component versions\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg component versions custom COMPONENT_NAME\n"
  printf "  gg component versions custom --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_NAME")"
    printf "    Custom component name\n"
    echo

  fi
}

# :command.usage
gg_remote_deployment_usage() {
  printf "gg remote-deployment - Manage remote deployments\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg remote-deployment COMMAND\n"
  printf "  gg remote-deployment [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Initialize a new remote deployment\n" "$(green "init")   "
  printf "  %s   Fetch the latest remote deployment configuration\n" "$(green "pull")   "
  printf "  %s   Deploy components to the specified remote target\n" "$(green "deploy") "
  printf "  %s   Check the status of a remote deployment by ID\n" "$(green "status") "
  printf "  %s   View details of the latest remote deployment\n" "$(green "view")   "
  printf "  %s   List deployment targets (the targets must have at least one deployment)\n" "$(green "targets")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
gg_remote_deployment_init_usage() {
  printf "gg remote-deployment init - Initialize a new remote deployment\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg remote-deployment init TARGET_NAME [OPTIONS]\n"
  printf "  gg remote-deployment init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--template, -t DEPLOYMENT_TEMPLATE")"
    printf "    See $command_name template for options.\n"
    printf "    %s\n" "Default: python/hello-world"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TARGET_NAME")"
    printf "    The name of the Thing or ThingGroup to deploy to\n"
    echo

  fi
}

# :command.usage
gg_remote_deployment_pull_usage() {
  printf "gg remote-deployment pull - Fetch the latest remote deployment configuration\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg remote-deployment pull TARGET_NAME\n"
  printf "  gg remote-deployment pull --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TARGET_NAME")"
    printf "    The name of the Thing or ThingGroup to deploy to\n"
    echo

  fi
}

# :command.usage
gg_remote_deployment_deploy_usage() {
  printf "gg remote-deployment deploy - Deploy components to the specified remote target\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg remote-deployment deploy COMPONENT_VERSION [OPTIONS]\n"
  printf "  gg remote-deployment deploy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--wait, -w")"
    printf "    Wait for the deployment to finish before exiting.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_VERSION")"
    printf "    The component version to deploy, updating the deployment.yaml.\n"
    echo

  fi
}

# :command.usage
gg_remote_deployment_status_usage() {
  printf "gg remote-deployment status - Check the status of a remote deployment by ID\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg remote-deployment status DEPLOYMENT_ID\n"
  printf "  gg remote-deployment status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEPLOYMENT_ID")"
    printf "    The name of the deployment\n"
    echo

  fi
}

# :command.usage
gg_remote_deployment_view_usage() {
  printf "gg remote-deployment view - View details of the latest remote deployment\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg remote-deployment view TARGET_NAME\n"
  printf "  gg remote-deployment view --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TARGET_NAME")"
    printf "    The name of the Thing or ThingGroup to view\n"
    echo

  fi
}

# :command.usage
gg_remote_deployment_targets_usage() {
  printf "gg remote-deployment targets - List deployment targets (the targets must have at least one deployment)\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg remote-deployment targets\n"
  printf "  gg remote-deployment targets --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
gg_local_deployment_usage() {
  printf "gg local-deployment - Manage local deployments\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg local-deployment COMMAND\n"
  printf "  gg local-deployment [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Deploy the component locally\n" "$(green "deploy")"
  printf "  %s   Remove the component locally\n" "$(green "remove")"
  printf "  %s   Retrieve the local deployment status\n" "$(green "status")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
gg_local_deployment_deploy_usage() {
  printf "gg local-deployment deploy - Deploy the component locally\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg local-deployment deploy COMPONENT_VERSION\n"
  printf "  gg local-deployment deploy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_VERSION")"
    printf "    The component version to deploy\n"
    echo

  fi
}

# :command.usage
gg_local_deployment_remove_usage() {
  printf "gg local-deployment remove - Remove the component locally\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg local-deployment remove COMPONENT_NAME\n"
  printf "  gg local-deployment remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMPONENT_NAME")"
    printf "    Component name to remove\n"
    echo

  fi
}

# :command.usage
gg_local_deployment_status_usage() {
  printf "gg local-deployment status - Retrieve the local deployment status\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  gg local-deployment status DEPLOYMENT_ID\n"
  printf "  gg local-deployment status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEPLOYMENT_ID")"
    printf "    The name of the deployment\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/aws_info.sh
aws_region() {
  local region=$(aws configure get region)
  if [ -z "$region" ]; then
    log ERROR "AWS region is not configured." >&2
    exit 1
  fi
  echo "$region"
}

aws_account() {
  local account=$(aws sts get-caller-identity --query Account --output text)
  if [ -z "$account" ]; then
    log ERROR "AWS account is not configured. Check if AWS credentials are set up." >&2
    exit 1
  fi
  echo "$account"
}

aws_user() {
  local user=$(aws sts get-caller-identity --query Arn --output text 2>/dev/null | awk -F'/' '{print $NF}')
  if [ -z "$user" ]; then
    log ERROR "AWS user is not configured. Check if AWS credentials are set up." >&2
    exit 1
  fi
  echo "$user"
}

# src/lib/check_component_name.sh
check_component_name() {
  component_name="$1"
  # Component name is used for S3 bucket name. Check S3 bucket name requirements.

  # Check the length of the bucket name
  if [ ${#component_name} -lt 3 ] || [ ${#component_name} -gt 63 ]; then
    # TODO - include prefix for a component name
    log ERROR "The component name must be between 3 and 63 characters long."
    return 1
  fi

  # Check if the component name only contains lowercase letters, numbers, and dashes
  if [[ ! "$component_name" =~ ^[a-z0-9-]+$ ]]; then
    log ERROR "The component name can only contain lowercase letters, numbers, and dashes."
    return 1
  fi

  # Check if the component name starts or ends with a dash
  if [[ "$component_name" == -* ]] || [[ "$component_name" == *- ]]; then
    log ERROR "The component name cannot start or end with a dash."
    return 1
  fi

  # Check if the component name is in an IP address format (only digits and dots)
  if [[ "$component_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    log ERROR "The component name cannot be an IP address."
    return 1
  fi
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/filters.sh
filter_is_project_root(){
  required_items=("component" "deployment" "config.yaml")
  missing_items=()

  for item in "${required_items[@]}"; do
    if [ ! -e "$item" ]; then
      missing_items+=("$item")
    fi
  done

  if [ ${#missing_items[@]} -gt 0 ]; then
    echo $(log ERROR "Run this command in the project root dir.")
  fi
}

filter_deployment_yaml_exists(){
  if [ ! -e "$deployment_yaml_path" ]; then
    echo $(log ERROR "deployment.yaml is missing. Have you done deployment init or pull?")
  fi
}

# src/lib/get_thing_type.sh
get_thing_type() {
  local name="$1"

  local is_thing
  is_thing=$(aws iot describe-thing --thing-name "$name" --query 'thingName' --output text 2>/dev/null)

  local is_group
  is_group=$(aws iot describe-thing-group --thing-group-name "$name" --query 'thingGroupName' --output text 2>/dev/null)

  if [ -n "$is_thing" ] && [ -n "$is_group" ]; then
    log ERROR "Found the name '$name' both in Thing and ThingGroup. Please use a different target name." >&2
    exit 1
  elif [ -n "$is_thing" ]; then
    echo "thing"
  elif [ -n "$is_group" ]; then
    echo "thinggroup"
  else
    log ERROR "The name '$name' does not belong to a Thing or a ThingGroup." >&2
    exit 1
  fi
}

# src/lib/log.sh
log() {
  local level=$1
  shift
  local message="$*"

  local level_priority=0

  local min_priority=0

  # level_priority
  case "$level" in
    DEBUG)  level_priority=1 ;;
    INFO)   level_priority=2 ;;
    WARN)   level_priority=3 ;;
    ERROR)  level_priority=4 ;;
    *)

      echo "Invalid log level: $level"
      return 1
      ;;
  esac

  # min_priority
  case "$MESSAGE_LEVEL" in
    DEBUG)  min_priority=1 ;;
    INFO)   min_priority=2 ;;
    WARN)   min_priority=3 ;;
    ERROR)  min_priority=4 ;;
    *)

      echo "Invalid LOG_LEVEL: $MESSAGE_LEVEL"
      return 1

      ;;
  esac

  local timestamp=$(date '+%Y-%m-%dT%H:%M:%S%z')

  # Compare level_priority with min_priority
  if [ "$level_priority" -ge "$min_priority" ]; then
    echo "$timestamp [$level] $message"
  fi
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/validations/validate_semantic_version.sh
validate_semantic_version() {
  local version="$1"
  local semver_regex="^([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9A-Za-z.-]+))?(\+([0-9A-Za-z.-]+))?$"
  [[ "$version" =~ $semver_regex ]] || echo $(log ERROR "Invalid semantic version: $version")
}

# :command.command_functions
# :command.function
gg_template_command() {

  # src/template_command.sh
  #echo "# this file is located in 'src/component_templates_command.sh'"
  #echo "# code for 'gg component templates' goes here"
  #echo "# you can edit it freely and regenerate (it will not be overwritten)"
  #inspect_args

  # Get relative path of this command to locate template dir

  # $command_name is a variable in bashly.yaml
  if ! command -v $command_name > /dev/null 2>&1; then
    log ERROR "$command_name is not in your PATH. Please add it to proceed." >&2
    exit 1
  fi

  list_template_dirs() {
    dir="${1:-.}" # Default to current directory if no argument is given
    find "$dir" -type d -mindepth 1 | while read -r candidate_dir; do
      if [[ -d "$candidate_dir/src" && -d "$candidate_dir/deployment" && -d "$candidate_dir/recipe" ]]; then
        echo "${candidate_dir#$dir/}"
      fi
    done | sort | yq -o yaml 'split(" ")'
  }

  TEMPLATE_DIR=$(dirname "$(which "$command_name")")/$template_dir_path
  log DEBUG "Template dir - $TEMPLATE_DIR"

  echo ""
  list_template_dirs $TEMPLATE_DIR
  echo ""
}

# :command.function
gg_component_init_command() {

  # src/component_init_command.sh
  # echo "# this file is located in 'src/component_init_command.sh'"
  # echo "# code for 'gdc component init' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  COMPONENT_NAME=${args[component_name]}
  TEMPLATE_DIR=${args[--template]}
  AWS_REGION=$(aws_region)
  AWS_USER=$(aws_user)
  AWS_ACCOUNT=$(aws_account)

  # Validate component name
  check_component_name $COMPONENT_NAME

  # Create project files and folders
  mkdir -p $COMPONENT_NAME/$src_dir_path
  mkdir -p $COMPONENT_NAME/$artifacts_dir_path
  mkdir -p $COMPONENT_NAME/$recipes_dir_path
  mkdir -p $COMPONENT_NAME/$deployment_dir_path
  touch $COMPONENT_NAME/$config_file

  log DEBUG "Initializeing component - $COMPONENT_NAME"

  # Create component S3 bucket
  S3_BUCKET_PREFIX=$(od -An -N8 -tx1 /dev/urandom | tr -dc 'a-z0-9' | fold -w 8 | head -n 1)
  S3_BUCKET_NAME=greengrass-component-$COMPONENT_NAME-$S3_BUCKET_PREFIX

  log DEBUG "Creating S3 bucket to store artifacts - $S3_BUCKET_NAME"
  cmd=(
    aws s3api create-bucket
    --bucket "$S3_BUCKET_NAME"
    --region "$AWS_REGION"
    --create-bucket-configuration "LocationConstraint=$AWS_REGION"
    --output text
  )
  log DEBUG "Executing - ${cmd[*]}"

  # Set context values in the config.yaml
  yq -i ".awsRegion = \"$AWS_REGION\"" $COMPONENT_NAME/$config_file
  yq -i ".awsAccount = \"$AWS_ACCOUNT\"" $COMPONENT_NAME/$config_file
  yq -i ".awsUser = \"$AWS_USER\"" $COMPONENT_NAME/$config_file
  yq -i ".componentName = \"$COMPONENT_NAME\"" $COMPONENT_NAME/$config_file
  yq -i ".s3BucketName = \"$S3_BUCKET_NAME\"" $COMPONENT_NAME/$config_file

  # Execute command
  S3_ARTIFACT_URI=$("${cmd[@]}")
  if [ -z "$S3_ARTIFACT_URI" ]; then
    log ERROR "Failed to create S3 bucket. Check AWS CLI configuration."
    exit 1
  fi
  log DEBUG "S3 URL - $S3_ARTIFACT_URI"

  #
  # Init with template recipe and artifact
  #

  # Locate template dir path
  TEMPLATE_DIR_FULL_PATH=$(dirname "$(which "$command_name")")/$template_dir_path/$TEMPLATE_DIR
  log DEBUG "Template directory full path - $TEMPLATE_DIR_FULL_PATH"

  # Copy template files in the project dir
  log DEBUG "Copying recipe.yaml to $COMPONENT_NAME/$recipe_yaml_path"
  cp $TEMPLATE_DIR_FULL_PATH/recipe/recipe.yaml $COMPONENT_NAME/$recipe_yaml_path
  log DEBUG "Copying files in src to $COMPONENT_NAME/$src_dir_path"
  cp $TEMPLATE_DIR_FULL_PATH/src/* $COMPONENT_NAME/$src_dir_path/

  # Update the template in the project dir.
  if [[ "$OSTYPE" == "darwin"* ]]; then
    log DEBUG "OS Type - $OSTYPE"
    sed -i '' \
      -e "s|AUTHOR_NAME|$AWS_USER|g" \
      -e "s|S3_BUCKET_NAME|$S3_BUCKET_NAME|g" \
      -e "s|COMPONENT_NAME|$COMPONENT_NAME|g" \
      "$COMPONENT_NAME/$recipe_yaml_path"
  else
    log DEBUG "OS Type - $OSTYPE"
    sed -i \
      -e "s|AUTHOR_NAME|$AWS_USER|g" \
      -e "s|S3_BUCKET_NAME|$S3_BUCKET_NAME|g" \
      -e "s|COMPONENT_NAME|$COMPONENT_NAME|g" \
      "$COMPONENT_NAME/$recipe_yaml_path"
  fi

  log INFO "$COMPONENT_NAME initialized"
}

# :command.function
gg_component_build_command() {

  # src/component_build_command.sh
  # echo "# this file is located in 'src/component_build_command.sh'"
  # echo "# code for 'gdc component build' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args
  COMPONENT_VERSION=${args[component_version]}
  COMPONENT_NAME=$(yq '.componentName' $config_file)
  S3_BUCKET_NAME=$(yq '.s3BucketName' $config_file)

  log DEBUG "Building component version - $COMPONENT_VERSION"

  # Update component version in recipe.yaml
  log DEBUG "Updating component version in the recipe.yaml - $COMPONENT_VERSION"
  yq -i ".ComponentVersion =\"$COMPONENT_VERSION\"" $recipe_yaml_path

  # Update S3 URI in recipe.yaml
  S3_URI="s3://$S3_BUCKET_NAME/artifacts/$COMPONENT_NAME/$COMPONENT_VERSION/files.zip"
  log DEBUG "Updating articact S3 URI in the recipe.yaml - $S3_URI"
  yq -i ".Manifests[].Artifacts[].URI = \"$S3_URI\"" $recipe_yaml_path

  # TODO - use this for the version replacement
  # NEW_VERSION="8.1.0"
  # yq -i '.Manifests[].Artifacts[].URI |= sub("[0-9]+\\.[0-9]+\\.[0-9]+", "'$NEW_VERSION'")' file.yml

  # Place the artifacts
  mkdir -p $artifacts_dir_path/$COMPONENT_NAME/$COMPONENT_VERSION
  cp $src_dir_path/*.* $artifacts_dir_path/$COMPONENT_NAME/$COMPONENT_VERSION
  cp $recipe_yaml_path $recipes_dir_path/recipe-$COMPONENT_VERSION.yaml
  cd $artifacts_dir_path/$COMPONENT_NAME/$COMPONENT_VERSION && zip -rq files.zip * && cd - > /dev/null

  log INFO "$COMPONENT_NAME - $COMPONENT_VERSION built"
}

# :command.function
gg_component_push_command() {

  # src/component_push_command.sh
  # echo "# this file is located in 'src/component_push_command.sh'"
  # echo "# code for 'gdc component push' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args
  COMPONENT_VERSION=${args[component_version]}
  COMPONENT_NAME=$(yq ".componentName" $config_file)

  COMPONENT_S3_BUCKET=$(yq ".s3BucketName" $config_file)

  cmd=(
    aws s3 cp
    $artifacts_dir_path/$COMPONENT_NAME/$COMPONENT_VERSION/files.zip
    s3://$COMPONENT_S3_BUCKET/artifacts/$COMPONENT_NAME/$COMPONENT_VERSION/files.zip
  )

  # Execute command
  log DEBUG "Executing - ${cmd[*]}"
  ${cmd[@]} > /dev/null 2>&1

  log INFO "$COMPONENT_NAME - $COMPONENT_VERSION pushed"
}

# :command.function
gg_component_create_command() {

  # src/component_create_command.sh
  # echo "# this file is located in 'src/component_create_command.sh'"
  # echo "# code for 'gdc component create' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args
  AWS_REGION=$(yq '.awsRegion' $config_file)
  AWS_ACCOUNT=$(yq '.awsAccount' $config_file)
  COMPONENT_VERSION=${args[component_version]}
  COMPONENT_NAME=$(yq ".componentName" $config_file)

  COMPONENT_S3_BUCKET=$(yq ".s3BucketName" $config_file)
  RECIPE_FILE_PATH=$recipes_dir_path/recipe-$COMPONENT_VERSION.yaml

  log DEBUG "Using recipe - $RECIPE_FILE_PATH"

  # Check if the component artifact exists in S3
  S3_PATH="s3://$COMPONENT_S3_BUCKET/artifacts/$COMPONENT_NAME/$COMPONENT_VERSION/files.zip"
  log INFO "Checking if component artifact exists at $S3_PATH"
  if ! aws s3 ls $S3_PATH > /dev/null 2>&1; then
    log ERROR "Component artifact not found at $S3_PATH"
    log ERROR "Please run 'gdc component push $COMPONENT_VERSION' first"
    exit 1
  else
    log INFO "Component artifact found at $S3_PATH"
  fi

  # Create component version
  cmd1=(
    aws greengrassv2 create-component-version
    --inline-recipe fileb://$RECIPE_FILE_PATH
    --output yaml
  )

  # create-component-version
  log DEBUG "Executing - ${cmd1[*]}"
  echo ""
  "${cmd1[@]}" | yq
  echo ""

  # Check the status of the create request
  cmd2=(
    aws greengrassv2 describe-component
    --arn arn:aws:greengrass:$AWS_REGION:$AWS_ACCOUNT:components:$COMPONENT_NAME:versions:$COMPONENT_VERSION
    --output yaml
  )
  log INFO "Checking the component status"
  log DEBUG "Executing - ${cmd2[*]}"

  echo ""
  #"${cmd2[@]}" | yq

  # Error handling
  if ! describe_result=$("${cmd2[@]}" 2>&1); then
    log ERROR "Failed to describe component: $COMPONENT_NAME:$COMPONENT_VERSION"
    echo "$describe_result"
    exit 1
  fi

  describe_output=$(echo "$describe_result" | yq)
  echo "$describe_output"
  echo ""

  log INFO "$COMPONENT_NAME - $COMPONENT_VERSION created successfully"

}

# :command.function
gg_component_pipeline_command() {

  # src/component_pipeline_command.sh
  # echo "# this file is located in 'src/component_pipeline_command.sh'"
  # echo "# code for 'gg component pipeline' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args
  COMPONENT_VERSION=${args[component_version]}

  log INFO "Running the build, push and create pipeline for $COMPONENT_VERSION"
  log INFO "Running component build"
  build=($0 component build $COMPONENT_VERSION); ${build[@]}
  log INFO "Running component push"
  push=($0 component push $COMPONENT_VERSION); ${push[@]}
  log INFO "Running component create"
  create=($0 component create $COMPONENT_VERSION); ${create[@]}

}

# :command.function
gg_component_versions_public_command() {

  # src/component_versions_public_command.sh
  # echo "# this file is located in 'src/component_versions_public_command.sh'"
  # echo "# code for 'gg component versions public' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  COMPONENT_NAME=${args[component_name]}
  AWS_REGION=$(yq '.awsRegion' $config_file)

  if [[ "$COMPONENT_NAME" != aws.greengrass.* ]]; then
    COMPONENT_NAME="aws.greengrass.$COMPONENT_NAME"
  fi

  cmd=(
    aws greengrassv2 list-component-versions
    --arn arn:aws:greengrass:$AWS_REGION:aws:components:$COMPONENT_NAME
    --output yaml
  )

  log DEBUG "Executing - ${cmd[*]}"
  echo ""
  "${cmd[@]}" | yq
  echo ""
}

# :command.function
gg_component_versions_custom_command() {

  # src/component_versions_custom_command.sh
  # echo "this file is located in 'src/component_versions_custom_command.sh'"
  # echo "code for 'gg component versions custom' goes here"
  # echo "you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  COMPONENT_NAME=${args[component_name]}
  AWS_REGION=$(yq '.awsRegion' $config_file)
  AWS_ACCOUNT=$(yq '.awsAccount' $config_file)

  cmd=(
    aws greengrassv2 list-component-versions
    --arn arn:aws:greengrass:$AWS_REGION:$AWS_ACCOUNT:components:$COMPONENT_NAME
    --output yaml
  )

  log DEBUG "Executing - ${cmd[*]}"
  echo ""
  "${cmd[@]}" | yq
  echo ""
}

# :command.function
gg_remote_deployment_init_command() {

  # src/remote_deployment_init_command.sh
  # echo "# this file is located in 'src/deployment_init_command.sh'"
  # echo "# code for 'gdc deployment init' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args
  TARGET_NAME=${args[target_name]}
  TEMPLATE_DIR=${args[--template]}
  COMPONENT_NAME=$(yq '.componentName' $config_file)
  AWS_REGION=$(yq '.awsRegion' $config_file)
  AWS_ACCOUNT=$(yq '.awsAccount' $config_file)

  TARGET_TYPE=$(get_thing_type $TARGET_NAME) || exit 1
  if [ "$TARGET_TYPE" = "thing" ] || [ "$TARGET_TYPE" = "thinggroup" ]; then
    log DEBUG "The target '$TARGET_NAME' is of type '$TARGET_TYPE'."
    TARGET_ARN="arn:aws:iot:$AWS_REGION:$AWS_ACCOUNT:$TARGET_TYPE/$TARGET_NAME"
  fi

  log DEBUG "TARGET_ARN - $TARGET_ARN"

  # TODO - get the latest component version(aws managed components) and replace the version in the yaml
  #get_latest_component_version(){
  #  aws greengrassv2 list-component-versions \
  #  --arn arn:aws:greengrass:$AWS_REGION:$AWS_ACCOUNT:components:$COMPONENT_NAME \
  #  | yq -r '.componentVersions[0].componentVersion'
  #}
  #log INFO "The latest component version for $COMPONENT_NAME - $LATEST_COMPONENT_VERSION"

  # Locate template dir path
  TEMPLATE_DIR_FULL_PATH=$(dirname "$(which "$command_name")")/$template_dir_path/$TEMPLATE_DIR
  log DEBUG "Template directory full path - $TEMPLATE_DIR_FULL_PATH"

  # Copy template files in the project dir
  log DEBUG "Copying $TEMPLATE_DIR_FULL_PATH/deployment/deployment.yaml to $deployment_yaml_path"
  cp $TEMPLATE_DIR_FULL_PATH/deployment/deployment.yaml $deployment_yaml_path

  # Update deployment.yaml
  log DEBUG "Updating deployment file - $deployment_yaml_path"

  if [[ "$OSTYPE" == "darwin"* ]]; then
    log DEBUG "OS Type - $OSTYPE"
    sed -i '' \
      -e "s|COMPONENT_NAME|$COMPONENT_NAME|g" \
      -e "s|TARGET_ARN|$TARGET_ARN|g" \
      $deployment_yaml_path
  else
    log DEBUG "OS Type - $OSTYPE"
    sed -i \
      -e "s|COMPONENT_NAME|$COMPONENT_NAME|g" \
      -e "s|TARGET_ARN|$TARGET_ARN|g" \
      $deployment_yaml_path
  fi

  log INFO "Deployment initialized with $deployment_yaml_path"

}

# :command.function
gg_remote_deployment_pull_command() {

  # src/remote_deployment_pull_command.sh
  # echo "# this file is located in 'src/deployment_pull_command.sh'"
  # echo "# code for 'gdc deployment pull' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  # This command uses list-deployments. See list-effective-deployments for your reference.

  TARGET_NAME=${args[target_name]}
  THING_TYPE=$(get_thing_type $TARGET_NAME)
  AWS_REGION=$(yq '.awsRegion' $config_file)
  AWS_ACCOUNT=$(yq '.awsAccount' $config_file)

  # Get DeploymentId of the latest deployment

  cmd1=(
    aws greengrassv2 list-deployments
    --target-arn "arn:aws:iot:$AWS_REGION:$AWS_ACCOUNT:$THING_TYPE/$TARGET_NAME"
    --query 'deployments[?isLatestForTarget==`true`]'
    --output yaml
  )

  log DEBUG "Executing - ${cmd1[*]}"

  # "${cmd[@]}" | yq
  DEPLOYMENT_ID=$("${cmd1[@]}" | yq '.[0].deploymentId')
  log INFO "Deployment ID: $DEPLOYMENT_ID"

  # Get deployment with the DeploymentId
  cmd2="aws greengrassv2 get-deployment \
  --deployment-id $DEPLOYMENT_ID \
  --output yaml"

  DEPLOYMENT=$($cmd2)
  log DEBUG "Pulling the latest deployment:"
  yq <<< "$DEPLOYMENT"

  # Check revisionId
  REVISION_ID=$(yq '.revisionId' <<< "$DEPLOYMENT")
  log DEBUG "Retrieve deployment revision - $REVISION_ID"

  # Pick up and save necessary parts
  yq '{"components": .components, "targetArn": .targetArn}' <<< "$DEPLOYMENT" > $deployment_yaml_path
  log INFO "Deployment pulled - $deployment_yaml_path"

}

# :command.function
gg_remote_deployment_deploy_command() {

  # src/remote_deployment_deploy_command.sh
  # echo "# this file is located in 'src/deployment_deploy_remote_command.sh'"
  # echo "# code for 'gdc deployment deploy remote' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  COMPONENT_VERSION=${args[component_version]}
  COMPONENT_NAME=$(yq '.componentName' $config_file)
  WAIT_FLAG=${args[--wait]}

  # Update component version only if COMPONENT_VERSION is specified
  if [ -n "$COMPONENT_VERSION" ]; then
    log INFO "Updating component version in the deployment.yaml - $COMPONENT_VERSION"
    yq -i ".components.\"$COMPONENT_NAME\".componentVersion = \"$COMPONENT_VERSION\"" $deployment_yaml_path
  else
    log INFO "COMPONENT_VERSION is not specified. Skipping update."
  fi

  # create-deployment
  cmd1=(
    aws greengrassv2 create-deployment
    --cli-input-yaml file://$deployment_yaml_path
    --output text
  )

  #
  # If there is a deployment name, append the last of the command
  #
  # DEPLOYMENT_NAME=${args[deployment_name]}
  # [ -n "$DEPLOYMENT_NAME" ] && cmd1+=(--deployment-name "$DEPLOYMENT_NAME")

  # Execute command
  log DEBUG "Executing - ${cmd1[*]}"
  DEPLOYMENT_ID=$("${cmd1[@]}") || {
    log ERROR "Failed to create deployment"
    exit 1
  }
  log INFO "DeploymentId: $DEPLOYMENT_ID"

  cmd2=(
    aws greengrassv2 get-deployment
    --deployment-id "$DEPLOYMENT_ID"
    --output yaml
  )
  log DEBUG "Executing - ${cmd2[*]}"

  # Wait until the deployment status will change
  if [ -n "$WAIT_FLAG" ] && [ "$WAIT_FLAG" -eq 1 ]; then
    log INFO "Polling deployment status for DeploymentId - $DEPLOYMENT_ID"
    POLL_INTERVAL=5
    MAX_RETRIES=12
    retries=0

    while true; do
      DEPLOYMENT_STATUS=$("${cmd2[@]}" | yq '.deploymentStatus') || {
        log ERROR "Failed to retrieve deployment status"
        exit 1
      }

      log INFO "$retries: Checking deployment status - $DEPLOYMENT_STATUS"

      if [[ "$DEPLOYMENT_STATUS" != "ACTIVE" ]]; then
        # log INFO "Deployment has reached final status: $DEPLOYMENT_STATUS"
        break
      fi

      if (( retries >= MAX_RETRIES )); then
        log ERROR "Timed out waiting for deployment to complete. Last status: $DEPLOYMENT_STATUS"
        exit 1
      fi

      sleep "$POLL_INTERVAL"
      retries=$((retries + 1))
    done
  fi

  echo ""
  "${cmd2[@]}" | yq
  echo ""

}

# :command.function
gg_remote_deployment_status_command() {

  # src/remote_deployment_status_command.sh
  #echo "# this file is located in 'src/deployment_status_command.sh'"
  #echo "# code for 'gdc deployment status' goes here"
  #echo "# you can edit it freely and regenerate (it will not be overwritten)"
  #inspect_args
  DEPLOYMENT_ID=${args[deployment_id]}

  # get-deployment
  cmd2=(
    aws greengrassv2 get-deployment
    --deployment-id "$DEPLOYMENT_ID"
    --output yaml
  )

  # Execute command
  log DEBUG "Executing - ${cmd2[*]}"

  echo ""
  "${cmd2[@]}" | yq
  echo ""
}

# :command.function
gg_remote_deployment_view_command() {

  # src/remote_deployment_view_command.sh
  # echo "# this file is located in 'src/deployment_view_command.sh'"
  # echo "# code for 'gg deployment view' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  TARGET_NAME=${args[target_name]}
  THING_TYPE=$(get_thing_type $TARGET_NAME) || exit 1
  AWS_REGION=$(yq '.awsRegion' $config_file)
  AWS_ACCOUNT=$(yq '.awsAccount' $config_file)

  #aws greengrassv2 get-deployment --deployment-id 21a5f908-e954-41b6-af2f-4c2dd78ddc7c --output yaml

  TARGET_ARN=arn:aws:iot:$AWS_REGION:$AWS_ACCOUNT:$THING_TYPE/$TARGET_NAME

  cmd1=(
    aws greengrassv2 list-deployments

    --target-arn $TARGET_ARN
    --query 'deployments[?isLatestForTarget == `true`].deploymentId'
    --output text
  )

  # Execute command
  log DEBUG "Executing - ${cmd1[*]}"
  DEPLOYMENT_ID=$("${cmd1[@]}") || {
    log ERROR "Failed fetch the deployment id for $TARGET_NAME"
    exit 1
  }
  log INFO "DeploymentId - $DEPLOYMENT_ID"

  cmd2=(
    aws greengrassv2 get-deployment
    --deployment-id "$DEPLOYMENT_ID"
    --output yaml
  )
  log DEBUG "Executing - ${cmd2[*]}"

  echo ""
  "${cmd2[@]}" | yq
  echo ""
}

# :command.function
gg_remote_deployment_targets_command() {

  # src/remote_deployment_targets_command.sh
  # echo "# this file is located in 'src/deployment_list_target_command.sh'"
  # echo "# code for 'gg deployment list-target' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  cmd=(
    aws greengrassv2 list-deployments --query
    deployments[].targetArn --output yaml
  )
  log DEBUG "Executing - ${cmd[*]}"

  echo ""
  "${cmd[@]}" | yq
  #"${cmd[@]}" | yq eval '[.[] | split("/")[-1]]' -P
  echo ""

}

# :command.function
gg_local_deployment_deploy_command() {

  # src/local_deployment_deploy_command.sh
  # echo "# this file is located in 'src/deployment_deploy_local_command.sh'"
  # echo "# code for 'gdc deployment deploy local' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  COMPONENT_VERSION=${args[component_version]}
  COMPONENT_NAME=$(yq '.componentName' $config_file)

  cmd1=(
    sudo /greengrass/v2/bin/greengrass-cli
    deployment create
    --recipeDir $recipes_dir_path
    --artifactDir $artifacts_dir_path
    --merge "$COMPONENT_NAME=$COMPONENT_VERSION"
  )

  log DEBUG "Executing - ${cmd1[*]}"
  echo ""
  "${cmd1[@]}" | yq || log ERROR "Failed to parse the output with yq"
  echo ""

}

# :command.function
gg_local_deployment_remove_command() {

  # src/local_deployment_remove_command.sh
  #echo "# this file is located in 'src/local_deployment_remove_command.sh'"
  #echo "# code for 'gg local-deployment remove' goes here"
  #echo "# you can edit it freely and regenerate (it will not be overwritten)"
  #inspect_args
  COMPONENT_NAME=$(yq '.componentName' $config_file)

  cmd=(
    sudo /greengrass/v2/bin/greengrass-cli
    deployment create
    --recipeDir component/recipes/
    --remove $COMPONENT_NAME
  )

  log DEBUG "Removing component - $COMPONENT_NAME"
  log DEBUG "Executing - ${cmd[*]}"
  echo ""
  "${cmd[@]}" | yq || log ERROR "Failed to parse the output with yq"
  echo ""
}

# :command.function
gg_local_deployment_status_command() {

  # src/local_deployment_status_command.sh
  #echo "# this file is located in 'src/local_deployment_status_command.sh'"
  #echo "# code for 'gg local-deployment status' goes here"
  #echo "# you can edit it freely and regenerate (it will not be overwritten)"
  #inspect_args

  DEPLOYMENT_ID=${args[deployment_id]}

  cmd=(
    sudo /greengrass/v2/bin/greengrass-cli
    deployment status -i $DEPLOYMENT_ID
  )

  log DEBUG "Executing - ${cmd1[*]}"

  RESULT=$("${cmd[@]}" 2>&1)

  echo ""
  echo "$RESULT" | yq || log ERROR "Failed to parse the output with yq: $RESULT"
  echo ""
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        gg_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export MESSAGE_LEVEL="${MESSAGE_LEVEL:-INFO}"

  env_var_names+=("MESSAGE_LEVEL")
  if [[ -n "${MESSAGE_LEVEL:-}" ]] && [[ ! ${MESSAGE_LEVEL:-} =~ ^(DEBUG|INFO|WARN|ERROR)$ ]]; then
    printf "%s\n" "MESSAGE_LEVEL environment variable must be one of: DEBUG, INFO, WARN, ERROR" >&2
    exit 1
  fi

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v aws >/dev/null 2>&1; then
    printf "missing dependency: aws\n" >&2
    printf "%s\n\n" "See https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html for setup instructions." >&2
    missing_deps=1
  else
    deps['aws']="$(command -v aws | head -n1)"
  fi

  # :dependency.filter
  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    printf "%s\n\n" "See https://mikefarah.gitbook.io/yq#install for setup instructions." >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    template)
      action="template"
      shift
      gg_template_parse_requirements "$@"
      shift $#
      ;;

    component)
      action="component"
      shift
      gg_component_parse_requirements "$@"
      shift $#
      ;;

    remote-deployment)
      action="remote-deployment"
      shift
      gg_remote_deployment_parse_requirements "$@"
      shift $#
      ;;

    local-deployment)
      action="local-deployment"
      shift
      gg_local_deployment_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      gg_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gg_template_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_template_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="template"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gg_component_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      gg_component_init_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      gg_component_build_parse_requirements "$@"
      shift $#
      ;;

    push)
      action="push"
      shift
      gg_component_push_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      gg_component_create_parse_requirements "$@"
      shift $#
      ;;

    pipeline)
      action="pipeline"
      shift
      gg_component_pipeline_parse_requirements "$@"
      shift $#
      ;;

    versions)
      action="versions"
      shift
      gg_component_versions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      gg_component_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gg_component_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="component init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --template | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -t COMPONENT_TEMPLATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_name']+x} ]]; then
          args['component_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_name']+x} ]]; then
    printf "missing required argument: COMPONENT_NAME\nusage: gg component init COMPONENT_NAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--template']:-} ]] || args['--template']="python/hello-world"

}

# :command.parse_requirements
gg_component_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="component build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_version']+x} ]]; then
    printf "missing required argument: COMPONENT_VERSION\nusage: gg component build COMPONENT_VERSION\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['component_version'] && -n $(validate_semantic_version "${args['component_version']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "COMPONENT_VERSION" "$(validate_semantic_version "${args['component_version']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_component_push_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_push_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="component push"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_version']+x} ]]; then
    printf "missing required argument: COMPONENT_VERSION\nusage: gg component push COMPONENT_VERSION\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['component_version'] && -n $(validate_semantic_version "${args['component_version']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "COMPONENT_VERSION" "$(validate_semantic_version "${args['component_version']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_component_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="component create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_version']+x} ]]; then
    printf "missing required argument: COMPONENT_VERSION\nusage: gg component create COMPONENT_VERSION\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['component_version'] && -n $(validate_semantic_version "${args['component_version']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "COMPONENT_VERSION" "$(validate_semantic_version "${args['component_version']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_component_pipeline_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_pipeline_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="component pipeline"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_version']+x} ]]; then
    printf "missing required argument: COMPONENT_VERSION\nusage: gg component pipeline COMPONENT_VERSION\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_component_versions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_versions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    public)
      action="public"
      shift
      gg_component_versions_public_parse_requirements "$@"
      shift $#
      ;;

    custom)
      action="custom"
      shift
      gg_component_versions_custom_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      gg_component_versions_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_component_versions_public_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_versions_public_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="component versions public"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_name']+x} ]]; then
          args['component_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_name']+x} ]]; then
    printf "missing required argument: COMPONENT_NAME\nusage: gg component versions public COMPONENT_NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
gg_component_versions_custom_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_component_versions_custom_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="component versions custom"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_name']+x} ]]; then
          args['component_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_name']+x} ]]; then
    printf "missing required argument: COMPONENT_NAME\nusage: gg component versions custom COMPONENT_NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
gg_remote_deployment_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_remote_deployment_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      gg_remote_deployment_init_parse_requirements "$@"
      shift $#
      ;;

    pull)
      action="pull"
      shift
      gg_remote_deployment_pull_parse_requirements "$@"
      shift $#
      ;;

    deploy)
      action="deploy"
      shift
      gg_remote_deployment_deploy_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      gg_remote_deployment_status_parse_requirements "$@"
      shift $#
      ;;

    view)
      action="view"
      shift
      gg_remote_deployment_view_parse_requirements "$@"
      shift $#
      ;;

    targets)
      action="targets"
      shift
      gg_remote_deployment_targets_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      gg_remote_deployment_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gg_remote_deployment_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_remote_deployment_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote-deployment init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --template | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -t DEPLOYMENT_TEMPLATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target_name']+x} ]]; then
          args['target_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['target_name']+x} ]]; then
    printf "missing required argument: TARGET_NAME\nusage: gg remote-deployment init TARGET_NAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--template']:-} ]] || args['--template']="python/hello-world"

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_remote_deployment_pull_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_remote_deployment_pull_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote-deployment pull"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target_name']+x} ]]; then
          args['target_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['target_name']+x} ]]; then
    printf "missing required argument: TARGET_NAME\nusage: gg remote-deployment pull TARGET_NAME\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_remote_deployment_deploy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_remote_deployment_deploy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote-deployment deploy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --wait | -w)

        # :flag.case_no_arg
        args['--wait']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_version']+x} ]]; then
    printf "missing required argument: COMPONENT_VERSION\nusage: gg remote-deployment deploy COMPONENT_VERSION [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['component_version'] && -n $(validate_semantic_version "${args['component_version']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "COMPONENT_VERSION" "$(validate_semantic_version "${args['component_version']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

  filter_error=$(filter_deployment_yaml_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_remote_deployment_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_remote_deployment_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote-deployment status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['deployment_id']+x} ]]; then
          args['deployment_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['deployment_id']+x} ]]; then
    printf "missing required argument: DEPLOYMENT_ID\nusage: gg remote-deployment status DEPLOYMENT_ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
gg_remote_deployment_view_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_remote_deployment_view_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote-deployment view"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['target_name']+x} ]]; then
          args['target_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['target_name']+x} ]]; then
    printf "missing required argument: TARGET_NAME\nusage: gg remote-deployment view TARGET_NAME\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_remote_deployment_targets_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_remote_deployment_targets_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote-deployment targets"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gg_local_deployment_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_local_deployment_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v /greengrass/v2/bin/greengrass-cli >/dev/null 2>&1; then
    printf "missing dependency: /greengrass/v2/bin/greengrass-cli\n" >&2
    printf "%s\n\n" "See https://docs.aws.amazon.com/greengrass/v2/developerguide/install-gg-cli.html for installation and setup instructions." >&2
    missing_deps=1
  else
    deps['/greengrass/v2/bin/greengrass-cli']="$(command -v /greengrass/v2/bin/greengrass-cli | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    deploy)
      action="deploy"
      shift
      gg_local_deployment_deploy_parse_requirements "$@"
      shift $#
      ;;

    remove)
      action="remove"
      shift
      gg_local_deployment_remove_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      gg_local_deployment_status_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      gg_local_deployment_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gg_local_deployment_deploy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_local_deployment_deploy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="local-deployment deploy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_version']+x} ]]; then
    printf "missing required argument: COMPONENT_VERSION\nusage: gg local-deployment deploy COMPONENT_VERSION\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['component_version'] && -n $(validate_semantic_version "${args['component_version']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "COMPONENT_VERSION" "$(validate_semantic_version "${args['component_version']:-}")" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_local_deployment_remove_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_local_deployment_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="local-deployment remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_name']+x} ]]; then
          args['component_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_name']+x} ]]; then
    printf "missing required argument: COMPONENT_NAME\nusage: gg local-deployment remove COMPONENT_NAME\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
gg_local_deployment_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        gg_local_deployment_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="local-deployment status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['deployment_id']+x} ]]; then
          args['deployment_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['deployment_id']+x} ]]; then
    printf "missing required argument: DEPLOYMENT_ID\nusage: gg local-deployment status DEPLOYMENT_ID\n" >&2

    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="1.0.0"
  set -e

  # :command.variables
  # :variable.definition
  declare -g command_name="gg"

  # :variable.definition
  declare -g config_file="config.yaml"

  # :variable.definition
  declare -g artifacts_dir_path="component/artifacts"

  # :variable.definition
  declare -g recipes_dir_path="component/recipes"

  # :variable.definition
  declare -g src_dir_path="component/src"

  # :variable.definition
  declare -g deployment_dir_path="deployment"

  # :variable.definition
  declare -g deployment_yaml_path="deployment/deployment.yaml"

  # :variable.definition
  declare -g recipe_yaml_path="component/recipe.yaml"

  # :variable.definition
  declare -g template_dir_path="templates"

  # :variable.definition
  declare -g default_template="python/hello-world"

  # :command.environment_variables_default
  export MESSAGE_LEVEL="${MESSAGE_LEVEL:-INFO}"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "template") gg_template_command ;;
    "component") gg_component_command ;;
    "component init") gg_component_init_command ;;
    "component build") gg_component_build_command ;;
    "component push") gg_component_push_command ;;
    "component create") gg_component_create_command ;;
    "component pipeline") gg_component_pipeline_command ;;
    "component versions") gg_component_versions_command ;;
    "component versions public") gg_component_versions_public_command ;;
    "component versions custom") gg_component_versions_custom_command ;;
    "remote-deployment") gg_remote_deployment_command ;;
    "remote-deployment init") gg_remote_deployment_init_command ;;
    "remote-deployment pull") gg_remote_deployment_pull_command ;;
    "remote-deployment deploy") gg_remote_deployment_deploy_command ;;
    "remote-deployment status") gg_remote_deployment_status_command ;;
    "remote-deployment view") gg_remote_deployment_view_command ;;
    "remote-deployment targets") gg_remote_deployment_targets_command ;;
    "local-deployment") gg_local_deployment_command ;;
    "local-deployment deploy") gg_local_deployment_deploy_command ;;
    "local-deployment remove") gg_local_deployment_remove_command ;;
    "local-deployment status") gg_local_deployment_status_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
